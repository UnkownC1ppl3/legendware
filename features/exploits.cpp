// This is an independent project of an individual developer. Dear PVS-Studio, please check it.
// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: http://www.viva64.com

#include "exploits.h"
#include "prediction.h"
#include "movement.h"
#include "aim.h"
#include "anti_aim.h"
#include "logs.h"
#include "fake_lag.h"
#include "features.h"
#include "dormant.h"
#include "..\config\config.h"

void Exploits::run(crypt_ptr <CUserCmd> cmd)
{
	in_attack = cmd->buttons & IN_ATTACK && !ctx->automatic_revolver;
	tickbase_shift = 0;

	if (in_attack)
	{
		double_tap_shot = false;
		last_shot = globals->curtime;
	}
	else if (aim->stop || aim->early_stop)
		last_shot = globals->curtime;

	if (!target_tickbase_shift)
	{
		if (ticks_allowed)
		{
			teleport(ticks_allowed, cmd);
			last_exploit_time = globals->realtime;
			ticks_allowed = 0;
		}

		tickbase_cycle = 0;
		return;
	}
	else if (ticks_allowed < target_tickbase_shift && ctx->weapon_config != WEAPON_CONFIG_INVALID)
	{
		if (*ctx->send_packet.get())
		{
			cmd->buttons &= ~IN_ATTACK;
			cmd->buttons &= ~IN_ATTACK2;
			last_exploit_time = globals->realtime;

			charging = true;
			tickbase_cycle = 0;
			return;
		}
		else
			target_tickbase_shift = min(target_tickbase_shift, ticks_allowed);
	}

	auto switch_tickbase = false;

	if (!tickbase_cycle)
	{
		switch_tickbase = trigger_lag(target_tickbase_shift, cmd) && ctx->weapon_config != WEAPON_CONFIG_INVALID && ctx->weapon() && ctx->weapon()->m_iItemDefinitionIndex() != WEAPON_REVOLVER && config->rage.weapon[ctx->weapon_config].lag_exploit;

		if (switch_tickbase)
			*ctx->send_packet.get() = true;

		ctx->last_tickbase = ctx->tickbase;
	}

	auto in_tickbase_cycle = false;

	if (tickbase_cycle <= target_tickbase_shift)
		in_tickbase_cycle = switch_tickbase || tickbase_cycle;

	if (in_tickbase_cycle)
		++tickbase_cycle;
	else
		tickbase_cycle = 0;

	if (ctx->weapon_config != WEAPON_CONFIG_INVALID)
	{
		if (in_attack)
		{
			if (double_tap)
			{
				double_tap = false;
				double_tap_shot = true;
				ticks_allowed = 0;
				tickbase_cycle = 0;
				last_double_tap_shot = globals->curtime;
				last_exploit_time = globals->realtime;

				teleport(target_tickbase_shift, cmd);
			}
			else if (hide_shots)
			{
				tickbase_shift = target_tickbase_shift;
				last_exploit_time = globals->realtime;
			}
		}
		else if (double_tap)
		{
			tickbase_shift = switch_tickbase ? 0 : target_tickbase_shift;
			last_exploit_time = globals->realtime;
		}
	}

	shift_tickbase(cmd);
	previous_tickbase_shift = tickbase_shift;
}

void Exploits::update()
{
	target_tickbase_shift = 0;

	if (!config->rage.enable)
		return;

	if (!ctx->weapon())
		return;

	auto valve_server = gamerules && gamerules->m_bIsValveDS();

	if (valve_server && config->misc.anti_untrusted)
		return;

	/*if (ctx->weapon()->m_iItemDefinitionIndex() == WEAPON_TASER)
	{
		double_tap = false;
		hide_shots = false;
	}
	else //-V550
	{
		if (last_double_tap_shot == FLT_MAX) //-V550
			double_tap = config->rage.double_tap_key.state;

		hide_shots = config->rage.hide_shots_key.state;
	}*/

	if (last_double_tap_shot == FLT_MAX)
		double_tap = config->rage.double_tap_key.state;

	hide_shots = config->rage.hide_shots_key.state;

	auto recharge_time = ctx->weapon_config == WEAPON_CONFIG_KNIFE ? 0.75f : 0.25f;

	if (!fake_lag->peek && globals->curtime - recharge_time > last_shot && globals->curtime - recharge_time > last_double_tap_shot)
	{
		double_tap = true;
		double_tap_shot = false;
		last_shot = FLT_MAX;
		last_double_tap_shot = FLT_MAX;
	}

	if (config->anti_aim.fake_duck_key.state)
		return;

	if (double_tap)
		target_tickbase_shift = valve_server ? 6 : 14;
	else if (hide_shots && last_double_tap_shot == FLT_MAX) //-V550
	{
		target_tickbase_shift = valve_server ? 6 : 7;
		ctx->tickbase -= target_tickbase_shift;
	}
}

bool Exploits::charge(crypt_ptr <CUserCmd> cmd)
{
	if (charging)
	{
		++ticks_allowed;
		memcpy(cmd.get(), input->GetUserCmd(cmd->command_number - 1), sizeof(CUserCmd)); //-V598

		cmd->buttons &= ~IN_ATTACK;
		cmd->buttons &= ~IN_ATTACK2;
		cmd->tickcount = 0x7F7FFFFF;

		if (abs(cmd->sidemove) == 1.01f)
			cmd->sidemove = cmd->command_number % 2 ? -1.01f : 1.01f;

		++cmd->command_number;

		auto verified = crypt_ptr <CVerifiedUserCmd> (input->GetVerifiedUserCmd(cmd->command_number));

		verified->m_cmd = *cmd.get();
		verified->m_crc = cmd->GetChecksum();



		if (ticks_allowed >= target_tickbase_shift)
		{
			charging = false;
			*ctx->send_packet.get() = true;
		}
		else
			*ctx->send_packet.get() = false;

		return true;
	}

	return false;
}

void Exploits::correct_charge(crypt_ptr <CUserCmd> cmd) //-V813
{
	if (*ctx->send_packet.get() && clientstate->m_NetChannel)
	{
		auto choked_packets = clientstate->m_NetChannel->m_nChokedPackets;

		if (choked_packets >= 0)
		{
			auto ticks_allowed_temp = ticks_allowed;
			auto command_number = cmd->command_number - choked_packets;

			do
			{
				auto command = &input->m_pCommands[cmd->command_number - MULTIPLAYER_BACKUP * (command_number / MULTIPLAYER_BACKUP) - choked_packets];

				if (!command || command->tickcount == 0x7F7FFFFF)
				{
					if (--ticks_allowed_temp < 0)
						ticks_allowed_temp = 0;

					ticks_allowed = ticks_allowed_temp;
				}

				++command_number;
				--choked_packets;
			}
			while (choked_packets >= 0);
		}
	}

	auto max_ticks_allowed = gamerules && gamerules->m_bIsValveDS() ? 6 : 14;

	if (ticks_allowed > max_ticks_allowed)
		ticks_allowed = clamp(ticks_allowed - 1, 0, target_tickbase_shift);
}

void Exploits::teleport(int ticks, crypt_ptr <CUserCmd> cmd)
{
	if (!ctx->weapon_data())
		return;

	auto teleporting = false;

	auto forwardmove = ctx->original_forwardmove;
	auto sidemove = ctx->original_sidemove;

	if (ctx->weapon_config != WEAPON_CONFIG_INVALID && engine_prediction->flags & FL_ONGROUND && ctx->local()->m_fFlags() & FL_ONGROUND)
	{
		if (config->rage.weapon[ctx->weapon_config].extended_teleport && ctx->local()->m_vecVelocity().Length2D() > 5.0f)
		{
			if (abs(forwardmove) > 5.0f)
			{
				teleporting = true;
				forwardmove = copysign(convars_manager->convars[CONVAR_CL_FORWARDSPEED]->GetFloat(), forwardmove);
			}
			else
				forwardmove = 0.0f;

			if (abs(sidemove) > 5.0f)
			{
				teleporting = true;
				sidemove = copysign(convars_manager->convars[CONVAR_CL_SIDESPEED]->GetFloat(), sidemove);
			}
			else
				sidemove = 0.0f;
		}
		else
		{
			forwardmove = 0.0f;
			sidemove = 0.0f;
		}
	}

	auto additional_stop_ticks = 0;

	if (teleporting && in_attack)
	{
		auto backup_tickbase = ctx->tickbase;
		auto backup_next_attack = ctx->local()->m_flNextAttack();
		auto backup_next_primary_attack = ctx->weapon()->m_flNextPrimaryAttack();

		ctx->local()->m_flNextAttack() = TICKS_TO_TIME(ctx->tickbase) + ctx->weapon_data()->cycle_time;
		ctx->weapon()->m_flNextPrimaryAttack() = TICKS_TO_TIME(ctx->tickbase) + ctx->weapon_data()->cycle_time; //-V656

		auto next_tickbase = ctx->tickbase + ticks;

		for (auto tickbase = next_tickbase; tickbase < next_tickbase + 14; ++tickbase)
		{
			ctx->tickbase = tickbase;

			if (ctx->local()->can_shoot())
				break;

			++additional_stop_ticks;
		}

		ctx->tickbase = backup_tickbase;
		ctx->local()->m_flNextAttack() = backup_next_attack;
		ctx->weapon()->m_flNextPrimaryAttack() = backup_next_primary_attack;
	}

	auto backup_tickbase = ctx->local()->m_nTickBase();
	auto backup_curtime = globals->curtime;

	movehelper->set_host(ctx->local().get());
	globals->curtime = TICKS_TO_TIME(ctx->local()->m_nTickBase());

	ctx->local()->post_think();
	++ctx->local()->m_nTickBase();

	movehelper->set_host(nullptr);

	auto commands_to_add = 0;
	auto next_command_number = cmd->command_number + 1;

	CUserCmd next_cmd;
	memcpy(&next_cmd, cmd.get(), sizeof(CUserCmd));

	next_cmd.command_number = next_command_number;
	next_cmd.buttons &= ~IN_ATTACK;
	next_cmd.buttons &= ~IN_ATTACK2;
	next_cmd.forwardmove = forwardmove;
	next_cmd.sidemove = sidemove;

	do
	{

		auto sequence_number = commands_to_add + next_cmd.command_number;

		auto command = crypt_ptr <CUserCmd> (input->GetUserCmd(sequence_number));
		auto verified_command = crypt_ptr <CVerifiedUserCmd> (input->GetVerifiedUserCmd(sequence_number));

		auto view_angles = movement_system->wish_angle;


		memcpy(command.get(), &next_cmd, sizeof(CUserCmd));

		command->command_number = sequence_number;
		command->predicted = true;
		command->buttons |= engine_prediction->buttons & IN_JUMP;
		command->viewangles = view_angles;
		if (ctx->local()->m_fFlags() & FL_ONGROUND && !(command->buttons & IN_JUMP))
		{
			if (ctx->automatic_peek && !ctx->automatic_peek_position.IsZero() && movement_system->holding_automatic_peek)
			{
				auto delta = ctx->automatic_peek_position - ctx->local()->m_vecOrigin();

				if (delta.Length() >= 10.0f)
				{
					view_angles.y = math::calculate_angle(ctx->local()->m_vecOrigin(), ctx->automatic_peek_position).y;

					command->forwardmove = convars_manager->convars[CONVAR_CL_FORWARDSPEED]->GetFloat();
					command->sidemove = 0.0f;
				}
			}
			else if (teleporting && in_attack)
			{
				RestoreData restore_data;
				engine_prediction->store_restore_data(restore_data);

				CUserCmd predict_command;
				memcpy(&predict_command, command.get(), sizeof(CUserCmd)); //-V598

				auto ticks_to_stop = 0;

				for (ticks_to_stop = 0; ticks_to_stop < 14; ++ticks_to_stop)
				{
					if (ctx->local()->m_vecVelocity().Length2D() + 1.0f < ctx->max_speed * 0.34f)
						break;

					Vector angle;
					math::vector_angles(ctx->local()->m_vecVelocity() * -1.0f, angle);

					angle.y = math::normalize_yaw(view_angles.y - angle.y);

					Vector direction;
					math::angle_vectors(angle, &direction, nullptr, nullptr);

					auto stop = direction * ctx->local()->m_vecVelocity().Length2D(); //-V688

					predict_command.forwardmove = stop.x;
					predict_command.sidemove = stop.y;

					engine_prediction->start(&predict_command);
				}

				if (ticks_to_stop)
				{
					engine_prediction->apply_restore_data(restore_data);

					// anti leak by MIRACLE
					// )))))


				}
			}
		}
		else if (!(ctx->local()->m_fFlags() & FL_ONGROUND) && command->buttons & IN_JUMP)
			command->buttons &= ~IN_JUMP;

	
		// anti leak by MIRACLE
		// )))))

		movement_system->edge_jump(command);
		command->predicted = false;

		memcpy(&verified_command->m_cmd, command.get(), sizeof(CUserCmd));
		verified_command->m_crc = command->GetChecksum();

		++clientstate->m_nChokedCommands;

		if (clientstate->m_NetChannel)
		{
			++clientstate->m_NetChannel->m_nChokedPackets;
			++clientstate->m_NetChannel->m_nOutSequenceNr;
		}

		++commands_to_add;
	}
	while (commands_to_add != ticks);

	if (!previous_tickbase_shift)
		tickbase_adjust = commands_to_add;

	ctx->local()->m_nTickBase() = backup_tickbase;
	globals->curtime = backup_curtime;

	prediction->m_bPreviousAckHadErrors = true;
	prediction->m_nCommandsPredicted = 0;

	*ctx->send_packet.get() = true;
}

void Exploits::shift_tickbase(crypt_ptr <CUserCmd> cmd)
{
	if (!tickbase_shift)
		return;

	if (!*ctx->send_packet.get())
		return;

	auto command_number = cmd->command_number;
	auto ticks = tickbase_shift;

	do
	{
		// anti leak by MIRACLE
		// )))))

		++clientstate->m_nChokedCommands;
		--ticks;
	}
	while (ticks);
}

bool Exploits::trigger_lag(int ticks, crypt_ptr <CUserCmd> cmd)
{
	if (aim->ticks_to_stop >= ticks)
		return false;

	auto shoot_position = ctx->shoot_position + ctx->local()->m_vecVelocity() * globals->intervalpertick * 2.0f;
	auto predicted_shoot_position = shoot_position + ctx->local()->m_vecVelocity() * globals->intervalpertick * (float)(ticks - aim->ticks_to_stop);

	for (auto i = 1; i <= globals->maxclients; ++i)
	{
		auto player = crypt_ptr <Player> ((Player*)entitylist->GetClientEntity(i));

		if (player.get() == ctx->local().get())
			continue;

		if (!player->valid(!ctx->friendly_fire))
			continue;

		if (player->IsDormant())
		{
			auto backup_abs_origin = player->GetAbsOrigin();

			if (dormant->adjust_sound(player))
			{
				CGameTrace trace;
				CGameTrace trace_prediction;

				Ray_t ray;
				CTraceFilterWorldAndPropsOnly filter;

				ray.Init(shoot_position, player->GetAbsOrigin() + player->m_vecViewOffset());
				enginetrace->TraceRay(ray, MASK_SHOT_HULL, &filter, &trace);

				ray.Init(predicted_shoot_position, player->GetAbsOrigin() + player->m_vecViewOffset());
				enginetrace->TraceRay(ray, MASK_SHOT_HULL, &filter, &trace_prediction);

				if (trace_prediction.fraction - trace.fraction > 0.5f)
					return true;
			}

			player->set_abs_origin(backup_abs_origin);
		}
		else
		{
			auto player_shoot_position = player->get_shoot_position();
			auto penetration_info = penetration->run(shoot_position, player_shoot_position, player, true);

			if (penetration_info.damage >= 1)
				continue;

			auto predicted_penetration_info = penetration->run(predicted_shoot_position, player_shoot_position, player, true);

			if (predicted_penetration_info.damage < 1)
				continue;

			return true;
		}
	}

	Vector view_angles;
	engine->GetViewAngles(view_angles);

	view_angles.x = 0.0f;

	Vector forward;
	math::angle_vectors(view_angles, &forward, nullptr, nullptr);

	forward.z = 0.0f;

	auto end = shoot_position + forward * 200.0f;
	auto end_prediction = predicted_shoot_position + forward * 200.0f;

	CGameTrace trace;
	CGameTrace trace_prediction;

	Ray_t ray;
	CTraceFilterWorldAndPropsOnly filter;

	ray.Init(shoot_position, end);
	enginetrace->TraceRay(ray, MASK_SHOT_HULL, &filter, &trace);

	ray.Init(predicted_shoot_position, end_prediction);
	enginetrace->TraceRay(ray, MASK_SHOT_HULL, &filter, &trace_prediction);

	return trace_prediction.fraction - trace.fraction > 0.5f;
}